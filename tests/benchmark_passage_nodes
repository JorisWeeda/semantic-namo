#!/usr/bin/env python3
from control.mppi_isaac.mppiisaac.planner.isaacgym_wrapper import ActorWrapper # type: ignore
from control.mppi_isaac.mppiisaac.utils.conversions import quaternion_to_yaw   # type: ignore

import os
import copy
import rospy
import hydra
import torch
import numpy as np
import matplotlib.pyplot as plt

import shapely
from shapely import buffer
from shapely.affinity import rotate
from shapely.ops import nearest_points

from datetime import datetime
from tf.transformations import quaternion_from_euler
from matplotlib.patches import Polygon
from matplotlib import colors

from environment import SimulateWorld
from scheduler import Scheduler
from scheduler import SVG


class Plotter:

    DATA_FOLDER = 'tu_delft_ws/15_msc_thesis/benchmark_polygon_plotter/'

    DIMENSION_ROOM = [2.1]

    def __init__(self,gym_world, scheduler, layout, config):
        self.gym_world = gym_world
        self.scheduler = scheduler

        self.config = config
        self.layout = layout

        self.svg = SVG(range_x=(-10, 10), range_y=(-10, 10),mass_threshold=10, path_inflation=0.3)

        self.data_folder = os.path.join(os.path.expanduser('~'), self.DATA_FOLDER)
        os.makedirs(self.data_folder, exist_ok=True)

    @classmethod
    def create_plotter(cls):
        rospy.init_node('test_plotter_node')
        hydra.initialize(config_path="../config", version_base=None)
    
        config = rospy.get_param('~config')
        layout = rospy.get_param('~layout')

        gym_world = SimulateWorld.create(hydra.compose(config), layout, False)
        scheduler = Scheduler.create_scheduler(layout)

        return cls(gym_world, scheduler, layout, config)

    def _create_file_path(self, name):
        file_name = f"{name}-{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}"
        return os.path.join(self.data_folder, file_name)

    def _plot_passage_scenarios(self, scenarios):
        _, axs = plt.subplots(1, 4, figsize=(25, 5))

        cmap = plt.cm.viridis_r
        norm = colors.Normalize(vmin=0, vmax=self.svg.mass_threshold)

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        cbar = plt.colorbar(sm, ax=axs, orientation='vertical', pad=0.05)
        cbar.set_label('Mass')

        for i, scenario in enumerate(scenarios):
            actor_wrappers, actor_state = scenario['actor_wrappers'], scenario['actor_state']
            actors = (actor_wrappers, actor_state)

            polygons, masses = self.svg.generate_polygons(actors, 0)

            passages = self.svg.generate_passages(polygons, masses,)

            for name, polygon in polygons.items():
                ax_polygon = Polygon(
                    polygon.exterior.coords, color=cmap(norm(masses[name])))
                axs[i].add_patch(ax_polygon)

            axs[i].scatter(passages[:, 0], passages[:, 1], c='blue', label='Passage Node')

            axs[i].legend()
            axs[i].set_xlim(-2, 2)
            axs[i].set_ylim(-2, 2)
            axs[i].set_aspect('equal')
            axs[i].set_title(f'Scenario {i + 1}')
            axs[i].grid(True, alpha=0.25)

        plt.show()

    def plot_inflation_nodes(self):
        hexagon_coords = [(0, 1), (0.866, 0.5), (0.866, -0.5),
                          (0, -1), (-0.866, -0.5), (-0.866, 0.5)]

        hexagon = shapely.Polygon(hexagon_coords)
        inflated_hexagon = buffer(hexagon, self.svg.path_inflation, cap_style='flat', join_style='mitre')

        _, axs = plt.subplots(1, 3, figsize=(25, 5))

        ax_polygon = Polygon(hexagon.exterior.coords, color='grey', label='Obstacle')
        axs[0].add_patch(copy.copy(ax_polygon))
        axs[1].add_patch(copy.copy(ax_polygon))
        axs[2].add_patch(copy.copy(ax_polygon))

        axs[1].plot(*inflated_hexagon.exterior.xy, 'r--', alpha=1.0, label='Inflated Obstacle Boundary')
        axs[2].plot(*inflated_hexagon.exterior.xy, 'r--', alpha=0.5, label='Inflated Obstacle Boundary')

        margin_distance = np.vstack([hexagon.exterior.coords[0], inflated_hexagon.exterior.coords[0]])
        axs[1].plot(margin_distance[:, 0], margin_distance[:, 1], c='red', alpha=0.8, label='Safety Margin (r)')

        initial_nodes = self.svg.generate_nodes([inflated_hexagon])
        axs[2].scatter(initial_nodes[:, 0], initial_nodes[:, 1], c='blue', label='Inflation Nodes')

        for ax in axs:
            ax.set_xlim(-5, 5)
            ax.set_ylim(-5, 5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.25)
            ax.legend()

        axs[0].set_title('Stage 1')
        axs[1].set_title('Stage 2')
        axs[2].set_title('Stage 3')
        plt.show()

    def plot_intersection_nodes(self):
        hexagon_coords = [(np.cos(theta) - 1.5, np.sin(theta)) for theta in np.linspace(0, 2*np.pi, 7)]
        squared_coords = [(x + 1., y) for (x, y) in [(-1, -1), (-1, 1), (1, 1), (1, -1), (-1, -1)]]

        hexagon = shapely.Polygon(hexagon_coords)
        squared = shapely.Polygon(squared_coords)

        inflated_hexagon = buffer(hexagon, self.svg.path_inflation, cap_style='flat', join_style='mitre')
        inflated_squared = buffer(squared, self.svg.path_inflation, cap_style='flat', join_style='mitre')

        _, axs = plt.subplots(1, 3, figsize=(25, 5))

        ax_hexagon = Polygon(hexagon.exterior.coords, color='grey', label='Obstacle 1')
        ax_squared = Polygon(squared.exterior.coords, color='grey', label='Obstacle 2')

        axs[0].add_patch(copy.copy(ax_hexagon))
        axs[0].add_patch(copy.copy(ax_squared))
        axs[1].add_patch(copy.copy(ax_hexagon))
        axs[1].add_patch(copy.copy(ax_squared))
        axs[2].add_patch(copy.copy(ax_hexagon))
        axs[2].add_patch(copy.copy(ax_squared))

        axs[1].plot(*inflated_hexagon.exterior.xy, color='red', linestyle='dashed', alpha=1.0, label='Inflated Obstacle 1 Boundary')
        axs[1].plot(*inflated_squared.exterior.xy, color='orange', linestyle='dashed', alpha=1.0, label='Inflated Obstacle 2 Boundary')
        
        axs[2].plot(*inflated_hexagon.exterior.xy, color='red', linestyle='dashed', alpha=0.5, label='Inflated Obstacle 1 Boundary')
        axs[2].plot(*inflated_squared.exterior.xy, color='orange', linestyle='dashed', alpha=0.5, label='Inflated Obstacle 2 Boundary')

        intersection_nodes = self.svg.get_intersection_points([inflated_hexagon, inflated_squared], self.svg.range_x, self.svg.range_y)
        axs[2].scatter(intersection_nodes[:, 0], intersection_nodes[:, 1], c='blue', label='Intersection Nodes')

        for ax in axs:
            ax.set_xlim(-5, 5)
            ax.set_ylim(-5, 5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.25)
            ax.legend()

        axs[0].set_title('Stage 1')
        axs[1].set_title('Stage 2')
        axs[2].set_title('Stage 3')
        plt.show()

    def plot_passage_nodes(self):
        hexagon_coords = [(np.cos(theta) - 1.5, np.sin(theta)) for theta in np.linspace(0, 2*np.pi, 7)]
        squared_coords = [(x + 1., y) for (x, y) in [(-1, -1), (-1, 1), (1, 1), (1, -1), (-1, -1)]]

        hexagon = shapely.Polygon(hexagon_coords)
        squared = shapely.Polygon(squared_coords)

        shapes = {'obstacle 1': hexagon, 'obstacle 2': squared}
        masses = {'obstacle 1': 8, 'obstacle 2': 5}

        cmap = plt.cm.viridis_r
        norm = colors.Normalize(vmin=0, vmax=self.svg.mass_threshold)

        _, axs = plt.subplots(1, 3, figsize=(25, 5))

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        cbar = plt.colorbar(sm, ax=axs, orientation='vertical', pad=0.05)
        cbar.set_label('Mass')

        ax_hexagon = Polygon(hexagon.exterior.coords, color=cmap(norm(8)), label='Obstacle 1')
        ax_squared = Polygon(squared.exterior.coords, color=cmap(norm(5)), label='Obstacle 2')

        axs[0].add_patch(copy.copy(ax_hexagon))
        axs[0].add_patch(copy.copy(ax_squared))
        axs[1].add_patch(copy.copy(ax_hexagon))
        axs[1].add_patch(copy.copy(ax_squared))
        axs[2].add_patch(copy.copy(ax_hexagon))
        axs[2].add_patch(copy.copy(ax_squared))

        nearest_point_hexagon, nearest_point_squared = nearest_points(hexagon, squared)
        axs[0].scatter(nearest_point_hexagon.x, nearest_point_hexagon.y, s=20, c='red', label='Nearest Point Obstacle 1')
        axs[0].scatter(nearest_point_squared.x, nearest_point_squared.y, s=20, c='orange', label='Nearest Point Obstacle 2')

        shortest_line = shapely.shortest_line(hexagon, squared)
        axs[1].plot(*shortest_line.coords.xy, c='blue', label='Shortest Line')

        passage_node = self.svg.generate_passages(shapes, masses)
        axs[2].scatter(passage_node[:, 0], passage_node[:, 1], c='blue', label='Passage Centroid')

        for ax in axs:
            ax.set_xlim(-5, 5)
            ax.set_ylim(-5, 5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.25)
            ax.legend()

        axs[0].set_title('Stage 1')
        axs[1].set_title('Stage 2')
        axs[2].set_title('Stage 3')
        plt.show()

    def plot_all_nodes(self):
        hexagon_coords = [(np.cos(theta) - 1.5, np.sin(theta)) for theta in np.linspace(0, 2*np.pi, 7)]
        squared_coords = [(x + 1., y) for (x, y) in [(-1, -1), (-1, 1), (1, 1), (1, -1), (-1, -1)]]

        hexagon = shapely.Polygon(hexagon_coords)
        squared = shapely.Polygon(squared_coords)

        inflated_hexagon = buffer(hexagon, self.svg.path_inflation, cap_style='flat', join_style='mitre')
        inflated_squared = buffer(squared, self.svg.path_inflation, cap_style='flat', join_style='mitre')

        shapes = {'obstacle 1': hexagon, 'obstacle 2': squared}
        masses = {'obstacle 1': 8, 'obstacle 2': 5}

        cmap = plt.cm.viridis_r
        norm = colors.Normalize(vmin=0, vmax=self.svg.mass_threshold)

        _, axs = plt.subplots(1, 4, figsize=(25, 5))

        sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        cbar = plt.colorbar(sm, ax=axs, orientation='vertical', pad=0.05)
        cbar.set_label('Mass')

        ax_hexagon = Polygon(hexagon.exterior.coords, color=cmap(norm(8)), label='Obstacle 1')
        ax_squared = Polygon(squared.exterior.coords, color=cmap(norm(5)), label='Obstacle 2')

        axs[0].add_patch(copy.copy(ax_hexagon))
        axs[0].add_patch(copy.copy(ax_squared))
        axs[1].add_patch(copy.copy(ax_hexagon))
        axs[1].add_patch(copy.copy(ax_squared))
        axs[2].add_patch(copy.copy(ax_hexagon))
        axs[2].add_patch(copy.copy(ax_squared))
        axs[3].add_patch(copy.copy(ax_hexagon))
        axs[3].add_patch(copy.copy(ax_squared))

        initial_nodes = self.svg.generate_nodes([inflated_hexagon, inflated_squared])
        axs[0].scatter(initial_nodes[:, 0], initial_nodes[:, 1], c='blue', label='Inflation Nodes')
        axs[3].scatter(initial_nodes[:, 0], initial_nodes[:, 1], c='blue', label='Nodes')

        intersection_nodes = self.svg.get_intersection_points([inflated_hexagon, inflated_squared], self.svg.range_x, self.svg.range_y)
        axs[1].scatter(intersection_nodes[:, 0], intersection_nodes[:, 1], c='blue', label='Intersection Nodes')
        axs[3].scatter(intersection_nodes[:, 0], intersection_nodes[:, 1], c='blue')

        passage_node = self.svg.generate_passages(shapes, masses)
        axs[2].scatter(passage_node[:, 0], passage_node[:, 1], c='blue', label='Passage Centroid')
        axs[3].scatter(passage_node[:, 0], passage_node[:, 1], c='blue')

        for ax in axs:
            ax.set_xlim(-5, 5)
            ax.set_ylim(-5, 5)
            ax.set_aspect('equal')
            ax.grid(True, alpha=0.25)
            ax.legend()

        axs[0].set_title('Inflation Nodes')
        axs[1].set_title('Intersection nodes')
        axs[2].set_title('Passage Nodes')
        axs[3].set_title('All nodes')

        plt.show()

    def generate_scenarios(self):
        scenarios = [
            {
                'actor_wrappers': [
                    ActorWrapper('robot', name='Robot',
                                 mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 1', mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 2', mass=5, size=(1.0, 1.0))
                ],
                'actor_state': torch.Tensor([
                    [0., 0., 0., *quaternion_from_euler(0., 0., 0.)],
                    [-.8, 0, 0., *quaternion_from_euler(0., 0., 0.)],
                    [.8, 0., 0., *quaternion_from_euler(0., 0., 0.)]
                ])
            },
            {
                'actor_wrappers': [
                    ActorWrapper('robot', name='Robot',
                                 mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 1', mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 2', mass=10, size=(1.0, 1.0))
                ],
                'actor_state': torch.Tensor([
                    [0., 0., 0., *quaternion_from_euler(0., 0., 0.)],
                    [-.8, 0, 0., *
                        quaternion_from_euler(0., 0., 45 / 180 * np.pi)],
                    [.8, 0., 0., *
                        quaternion_from_euler(0., 0., 10 / 180 * np.pi)]
                ])
            },
            {
                'actor_wrappers': [
                    ActorWrapper('robot', name='Robot',
                                 mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 1', mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 2', mass=10, size=(1.0, 2.5))
                ],
                'actor_state': torch.Tensor([
                    [0., 0., 0., *quaternion_from_euler(0., 0., 0.)],
                    [-.8, -1, 0., *quaternion_from_euler(0., 0., 0.)],
                    [.8, -.5, 0., *quaternion_from_euler(0., 0., 0.)]
                ])
            },
            {
                'actor_wrappers': [
                    ActorWrapper('robot', name='Robot',
                                 mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 1', mass=5, size=(1.0, 1.0)),
                    ActorWrapper('box', name='Obs 2', mass=10, size=(1.0, 2.5))
                ],
                'actor_state': torch.Tensor([
                    [0., 0., 0., *quaternion_from_euler(0., 0., 0.)],
                    [-.8, -1, 0., *
                        quaternion_from_euler(0., 0., 10 / 180 * np.pi)],
                    [0.8, -.5, 0., *quaternion_from_euler(0., 0., 0.)]
                ])
            },
        ]

        self._plot_passage_scenarios(scenarios)

    def plot_experiment_1(self):
        _, axs = plt.subplots(1, len(self.DIMENSION_ROOM))

        for i, dimension in enumerate(self.DIMENSION_ROOM):
            x = y = dimension

            self.gym_world.params['range_x'] = [-x, x]
            self.gym_world.params['range_y'] = [-y, y]
    
            mass_threshold = self.gym_world.params['scheduler']['mass_threshold']

            self.scheduler.robot_goal_pos[0] = x - 0.5
            self.scheduler.robot_goal_pos[1] = y - 0.5
 
            robot_dof = self.gym_world.get_robot_dofs()
            robot_dof[0] = -x + 0.5
            robot_dof[2] = -y + 0.5
            robot_dof[4] = torch.pi / 2

            self.gym_world.params["environment"]["robot"]["init_state"] = [robot_dof[0], robot_dof[2], 0]
            self.gym_world.params["goal"] = self.scheduler.robot_goal_pos

            q_init = [robot_dof[0], robot_dof[2], 0]
            q_goal = self.scheduler.robot_goal_pos

            additions = self.gym_world.grid_additions()
            actors = [ActorWrapper(**addition) for addition in additions]

            for actor in actors:
                actor_mass_noise = np.random.uniform(-actor.noise_percentage_mass * actor.mass, actor.noise_percentage_mass * actor.mass)
                actor.mass = actor.mass + actor_mass_noise
                
                print(actor.name, actor.mass, actor.init_pos, actor.init_ori, actor.size)

                if actor.fixed:
                    continue

                mass = actor.mass
                size = [dim - 1e-1 for dim in actor.size]

                obs_pos = torch.tensor(actor.init_pos)
                obs_rot = quaternion_to_yaw(torch.tensor(actor.init_ori))

                corners = [
                    (obs_pos[0] - size[0] / 2, obs_pos[1] - size[1] / 2),
                    (obs_pos[0] + size[0] / 2, obs_pos[1] - size[1] / 2),
                    (obs_pos[0] + size[0] / 2, obs_pos[1] + size[1] / 2),
                    (obs_pos[0] - size[0] / 2, obs_pos[1] + size[1] / 2)
                ]

                polygon = shapely.Polygon(corners)
                polygon = rotate(polygon, obs_rot, origin=obs_pos, use_radians=True)
    
                patch_polygon = Polygon(polygon.exterior.coords, closed=True, color=plt.cm.viridis_r(mass / mass_threshold))
                axs.add_patch(patch_polygon)

            axs.plot(q_init[0], q_init[1], color='green', marker='o', markersize=10, label='Start Node')
            axs.plot(q_goal[0], q_goal[1], color='red', marker='o', markersize=10, label='Goal Node')

            axs.set_xlim(-x, x)
            axs.set_ylim(-y, y)

            axs.set_title(f'Room {i + 1}')
            axs.set_xlabel('x-axis')
            axs.set_ylabel('y axis')
            axs.set_aspect('equal')

        sm = plt.cm.ScalarMappable(cmap=plt.cm.viridis_r, norm=plt.Normalize(vmin=0, vmax=mass_threshold))
        cbar = plt.colorbar(sm, ax=axs)
        cbar.set_label('Mass')
        plt.show()

    def plot_experiment_2(self):
        _, axs = plt.subplots(1, len(self.DIMENSION_ROOM))

        for i, dimension in enumerate(self.DIMENSION_ROOM):
            x = y = dimension

            self.gym_world.params['range_x'] = [-x, x]
            self.gym_world.params['range_y'] = [-y, y]
    
            self.gym_world.params['stationary_percentage'] = 0.01
            self.gym_world.params['adjustable_percentage'] = 0.40

            self.gym_world.params['stationary_size_noise'] = 0.5
            self.gym_world.params['adjustable_size_noise'] = 0.5
 
            mass_threshold = self.gym_world.params['scheduler']['mass_threshold']

            self.scheduler.robot_goal_pos[0] = x - 0.5
            self.scheduler.robot_goal_pos[1] = y - 0.5
 
            robot_dof = self.gym_world.get_robot_dofs()
            robot_dof[0] = -x + 0.5
            robot_dof[2] = -y + 0.5
            robot_dof[4] = torch.pi / 2

            self.gym_world.params["environment"]["robot"]["init_state"] = [robot_dof[0], robot_dof[2], 0]
            self.gym_world.params["goal"] = self.scheduler.robot_goal_pos

            q_init = [robot_dof[0], robot_dof[2], 0]
            q_goal = self.scheduler.robot_goal_pos

            additions = self.gym_world.random_additions()
            actors = [ActorWrapper(**addition) for addition in additions]

            for actor in actors:
                actor_mass_noise = np.random.uniform(-actor.noise_percentage_mass * actor.mass, actor.noise_percentage_mass * actor.mass)
                actor.mass = actor.mass + actor_mass_noise

                print(actor.name, actor.mass, actor.init_pos, actor.init_ori, actor.size)

                if actor.fixed:
                    continue

                mass = actor.mass
                size = [dim - 1e-1 for dim in actor.size]

                obs_pos = torch.tensor(actor.init_pos)
                obs_rot = quaternion_to_yaw(torch.tensor(actor.init_ori))

                corners = [
                    (obs_pos[0] - size[0] / 2, obs_pos[1] - size[1] / 2),
                    (obs_pos[0] + size[0] / 2, obs_pos[1] - size[1] / 2),
                    (obs_pos[0] + size[0] / 2, obs_pos[1] + size[1] / 2),
                    (obs_pos[0] - size[0] / 2, obs_pos[1] + size[1] / 2)
                ]

                polygon = shapely.Polygon(corners)
                polygon = rotate(polygon, obs_rot, origin=obs_pos, use_radians=True)
    
                patch_polygon = Polygon(polygon.exterior.coords, closed=True, color=plt.cm.viridis_r(mass / mass_threshold))
                axs.add_patch(patch_polygon)

            axs.plot(q_init[0], q_init[1], color='green', marker='o', markersize=10, label='Start Node')
            axs.plot(q_goal[0], q_goal[1], color='red', marker='o', markersize=10, label='Goal Node')

            axs.set_xlim(-x, x)
            axs.set_ylim(-y, y)

            axs.set_title(f'Room {i + 1}')
            axs.set_xlabel('x-axis')
            axs.set_ylabel('y axis')
            axs.set_aspect('equal')

        sm = plt.cm.ScalarMappable(cmap=plt.cm.viridis_r, norm=plt.Normalize(vmin=0, vmax=mass_threshold))
        cbar = plt.colorbar(sm, ax=axs)
        cbar.set_label('Mass')
        plt.show()



if __name__ == "__main__":

    plotter = Plotter.create_plotter()
    plotter.plot_experiment_1()
    plotter.plot_experiment_2()

    rospy.signal_shutdown("Benchmark tasks completed. Shutting down ROS.")
